import 'dotenv/config';import fs from 'node:fs/promises';import { createPublicClient, createWalletClient, http, isAddress, parseEther, parseUnits, formatEther, formatUnits } from 'viem';import { privateKeyToAccount } from 'viem/accounts';import { sepolia } from 'viem/chains';import { giwaSepolia } from './config.mjs';import { publicActionsL1, publicActionsL2, walletActionsL1, walletActionsL2, getL2TransactionHashes } from 'viem/op-stack';
const timeout=Number(process.env.RPC_TIMEOUT_MS||30000);const L1_RPC=process.env.L1_RPC||'https://rpc.sepolia.org';const L2_RPC=process.env.L2_RPC||'https://sepolia-rpc.giwa.io';const CONCURRENCY=Number(process.env.CONCURRENCY||5);const ROUNDS=Number(process.env.ROUNDS||1);const DEPOSIT_ETH=parseEther(String(process.env.DEPOSIT_ETH||'0.001'));const DEPOSIT_L2_GAS=Number(process.env.DEPOSIT_L2_GAS||200000);const ARTIFACT=process.env.ARTIFACT||'artifacts/ERC20Lite.json';const TOKENS_PER_ROUND=Number(process.env.TOKENS_PER_ROUND||50);const NAME_BASE=process.env.NAME_BASE||'GiwaToken';const SYMBOL_BASE=process.env.SYMBOL_BASE||'GIW';const DECIMALS=Number(process.env.DECIMALS||18);const SUPPLY_HUMAN=String(process.env.SUPPLY_HUMAN||'1000000');const AIRDROP_COUNT=Number(process.env.AIRDROP_COUNT||5);const AIRDROP_PER_ADDRESS=String(process.env.AIRDROP_PER_ADDRESS||'10');const LOOKBACK_BLOCKS=Number(process.env.LOOKBACK_BLOCKS||2000);const MAX_SCAN=Number(process.env.MAX_SCAN||600);const SLEEP_MS=Number(process.env.SLEEP_MS||1500);const JITTER_MS=Number(process.env.JITTER_MS||300);const KEYS_FILE=process.env.KEYS||'data/keys.txt';const L2_RECEIPT_TIMEOUT_MS=Number(process.env.L2_RECEIPT_TIMEOUT_MS||600000);const L2_POLL_MS=Number(process.env.L2_POLL_MS||3000);const SKIP_DEPOSIT=String(process.env.SKIP_DEPOSIT||'').toLowerCase()==='true';const SKIP_DEPLOY=String(process.env.SKIP_DEPLOY||'').toLowerCase()==='true';const SKIP_AIRDROP=String(process.env.SKIP_AIRDROP||'').toLowerCase()==='true';
const L1_ABI=[{type:'function',name:'depositETHTo',stateMutability:'payable',inputs:[{name:'_to',type:'address'},{name:'_l2Gas',type:'uint32'},{name:'_data',type:'bytes'}],outputs:[]}];const ERC20_ABI=[{type:'function',name:'decimals',stateMutability:'view',inputs:[],outputs:[{type:'uint8'}]},{type:'function',name:'balanceOf',stateMutability:'view',inputs:[{name:'a',type:'address'}],outputs:[{type:'uint256'}]},{type:'function',name:'transfer',stateMutability:'nonpayable',inputs:[{name:'to',type:'address'},{name:'amt',type:'uint256'}],outputs:[{type:'bool'}]},];
const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));const jittered=(ms)=>ms+(JITTER_MS>0?Math.floor(Math.random()*(JITTER_MS+1)):0);
async function loadKeys(){const s=await fs.readFile(KEYS_FILE,'utf8').catch(()=> '');return s.split(/\r?\n/).map(x=>x.trim()).filter(Boolean).filter(x=>/^0x[0-9a-fA-F]{64}$/.test(x));}
function makeClients(pk){const account=privateKeyToAccount(pk);const publicClientL1=createPublicClient({chain:sepolia,transport:http(L1_RPC,{timeout})}).extend(publicActionsL1());const publicClientL2=createPublicClient({chain:giwaSepolia,transport:http(L2_RPC,{timeout})}).extend(publicActionsL2());const walletClientL1=createWalletClient({account,chain:sepolia,transport:http(L1_RPC,{timeout})}).extend(walletActionsL1());const walletClientL2=createWalletClient({account,chain:giwaSepolia,transport:http(L2_RPC,{timeout})}).extend(walletActionsL2());return { account, publicClientL1, publicClientL2, walletClientL1, walletClientL2 } }
async function depositStep(c){const bridgeAddr=giwaSepolia.contracts.l1StandardBridge[sepolia.id].address;const hash=await c.walletClientL1.writeContract({address:bridgeAddr,abi:L1_ABI,functionName:'depositETHTo',args:[c.account.address,Number(process.env.DEPOSIT_L2_GAS||200000),'0x'],value:DEPOSIT_ETH});const l1r=await c.publicClientL1.waitForTransactionReceipt({hash});const [l2Hash]=getL2TransactionHashes(l1r);await c.publicClientL2.waitForTransactionReceipt({hash:l2Hash,timeout:L2_RECEIPT_TIMEOUT_MS,pollingInterval:L2_POLL_MS});return { l1Hash: hash, l2Hash } }
async function deployToken(pub,wallet,account,idx){const {abi,bytecode}=JSON.parse(await fs.readFile(ARTIFACT,'utf8'));if(!abi||!bytecode?.startsWith('0x'))throw new Error(`Artifact invalid: ${ARTIFACT}`);const name=`${NAME_BASE}${idx}`;const symbol=`${SYMBOL_BASE}${idx}`;const supply=parseUnits(SUPPLY_HUMAN,DECIMALS);const args=[name,symbol,DECIMALS,supply];const hash=await wallet.deployContract({abi,bytecode,account,args});const rcpt=await pub.waitForTransactionReceipt({hash});return { hash, address: rcpt.contractAddress, name, symbol } }
async function discoverEOAs(pub,want){const tip=await pub.getBlockNumber();const candidates=new Set();for(let i=0n;i<BigInt(MAX_SCAN);i++){const bn=tip-i;if(bn<1n||i>=BigInt(LOOKBACK_BLOCKS))break;const block=await pub.getBlock({blockNumber:bn,includeTransactions:true});for(const tx of block.transactions){if(tx.from)candidates.add(tx.from);if(tx.to)candidates.add(tx.to);}if(candidates.size>want*6)break;if(i%50n===0n&&i!==0n)await sleep(100);}const arr=Array.from(candidates).filter(a=>isAddress(a));const eoas=[];for(const a of arr){try{const code=await pub.getBytecode({address:a});if(code===null)eoas.push(a);}catch{}if(eoas.length>=want*2)break;}const picks=[];while(picks.length<want&&eoas.length){const idx=Math.floor(Math.random()*eoas.length);const [chosen]=eoas.splice(idx,1);if(!picks.includes(chosen))picks.push(chosen);}return picks }
async function airdropToken(pub,wallet,token,perHuman,count){const decimals=await pub.readContract({address:token,abi:ERC20_ABI,functionName:'decimals'});const per=parseUnits(String(perHuman),decimals);const addrs=await discoverEOAs(pub,count);console.log(`    â€¢ Airdrop to ${addrs.length} EOA @ ${perHuman} tokens each`);for(let i=0;i<addrs.length;i++){const to=addrs[i];const hash=await wallet.writeContract({address:token,abi:ERC20_ABI,functionName:'transfer',args:[to,per]});console.log(`      [${i+1}/${addrs.length}] -> ${to} | ${hash}`);await pub.waitForTransactionReceipt({hash});if(i+1<addrs.length)await sleep(jittered(SLEEP_MS));}}
async function runForWallet(pk,idx,total,globalStart){const { account, publicClientL1, publicClientL2, walletClientL1, walletClientL2 }=makeClients(pk);const hdr=`W${idx}/${total} ${account.address}`;let nextIdx=globalStart;try{console.log(`\n=== ${hdr} ===`);for(let r=1;r<=ROUNDS;r++){console.log(`- Round ${r}/${ROUNDS}`);if(!SKIP_DEPOSIT){console.log(`  â€¢ Deposit ${formatEther(DEPOSIT_ETH)} ETH (L1->L2)`);const dep=await depositStep({account,publicClientL1,publicClientL2,walletClientL1,walletClientL2});console.log(`    L1: ${dep.l1Hash}`);console.log(`    L2: ${dep.l2Hash}`);}else console.log('  â€¢ Deposit SKIPPED');if(!SKIP_DEPLOY){console.log(`  â€¢ Deploy ${TOKENS_PER_ROUND} token(s) from ${ARTIFACT}`);for(let t=1;t<=TOKENS_PER_ROUND;t++){const tok=await deployToken(publicClientL2,walletClientL2,account,nextIdx++);console.log(`    - Deployed ${tok.name} (${tok.symbol}) at ${tok.address} (tx: ${tok.hash})`);if(!SKIP_AIRDROP)await airdropToken(publicClientL2,walletClientL2,tok.address,Number(AIRDROP_PER_ADDRESS),AIRDROP_COUNT);else console.log('    â€¢ Airdrop SKIPPED');if(t<TOKENS_PER_ROUND)await sleep(jittered(SLEEP_MS));}}else console.log('  â€¢ Deploy SKIPPED');}console.log(`âœ… Done ${hdr}`);}catch(e){console.error(`âŒ Error ${hdr}:`,e?.shortMessage||e?.message||String(e));}}
async function runPool(keys){let idx=0;const n=keys.length;let globalTokenIndex=1;const workers=Array.from({length:Math.min(CONCURRENCY,n)},()=> (async function loop(){while(true){const i=idx++;if(i>=n)break;const myStart=(globalTokenIndex+=TOKENS_PER_ROUND)-TOKENS_PER_ROUND;await runForWallet(keys[i],i+1,n,myStart+1);}})());await Promise.all(workers);}
async function main(){const s=await fs.readFile(KEYS_FILE,'utf8').catch(()=> '');const keys=s.split(/\r?\n/).map(x=>x.trim()).filter(Boolean).filter(x=>/^0x[0-9a-fA-F]{64}$/.test(x));if(keys.length===0)throw new Error(`No private keys in ${KEYS_FILE}`);const neededPerToken=BigInt(AIRDROP_COUNT)*parseUnits(String(AIRDROP_PER_ADDRESS),DECIMALS);console.log(`Supply check: per token need >= ${formatUnits(neededPerToken,DECIMALS)} tokens for airdrops.`);console.log(`Loaded ${keys.length} wallet(s). CONCURRENCY=${CONCURRENCY}. ROUNDS=${ROUNDS}.`);await runPool(keys);console.log('\nðŸŽ‰ All wallets finished.');}
main().catch(e=>{console.error(e);process.exit(1);});
